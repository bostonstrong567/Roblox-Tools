local Module = {}
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")

-- Function to add randomized movement
local function addRandomDeviation(position)
    local randomX = math.random(-2, 2)
    local randomY = math.random(-2, 2)
    local randomZ = math.random(-2, 2)
    return position + Vector3.new(randomX, randomY, randomZ)
end

-- Function to simulate obstacle navigation (conceptual)
local function navigateObstacles(start, destination)
    -- Implement some pathfinding algorithm here
    -- For now, let's just return a list of points that simulates some path
    return {start, addRandomDeviation(start), addRandomDeviation(destination), destination}
end

function Module.UltimateTween(object_to_tween, destination, options)
    local is_model = options.isModel or false
    local tween_speed = options.speed or "Default"
    local update_rate = options.updateRate or 1/30

    local player = game.Players.LocalPlayer
    local humanoid = player.Character:WaitForChild("Humanoid")
    local walk_speed = humanoid.WalkSpeed

    local function getTweenInfo()
        local time, easing_style, easing_direction = 5, Enum.EasingStyle.Linear, Enum.EasingDirection.In

        if tween_speed == "Slow" then
            time = 10
        elseif tween_speed == "Fast" then
            time = 1
        elseif tween_speed == "AntiCheat" then
            local distance_to_destination = (destination.Position - object_to_tween.Position).Magnitude
            time = distance_to_destination / walk_speed
            easing_style = Enum.EasingStyle.Linear
        end

        return TweenInfo.new(time, easing_style, easing_direction)
    end

    local function applyTween(target, end_position, tween_info)
        local tween_goal = {}
        tween_goal.Position = end_position
        local tween = TweenService:Create(target, tween_info, tween_goal)
        tween:Play()
    end

    local function updateTween()
        local tween_info = getTweenInfo()

        if tween_speed == "AntiCheat" then
            local path_points = navigateObstacles(object_to_tween.Position, destination.Position)
            for _, point in pairs(path_points) do
                applyTween(object_to_tween, point, tween_info)
                wait(tween_info.Time)
            end
        else
            if is_model then
                for _, part in pairs(object_to_tween:GetChildren()) do
                    if part:IsA("Part") then
                        applyTween(part, destination.Position, tween_info)
                    end
                end
            else
                applyTween(object_to_tween, destination.Position, tween_info)
            end
        end
    end

    local connection
    connection = RunService.Heartbeat:Connect(function()
        updateTween()
        wait(update_rate)
    end)

    -- Optional: Disconnect the update function after some time or under certain conditions
    -- connection:Disconnect()
end

return Module
