local Player = game:GetService("Players").LocalPlayer
local Module = {}
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")

function Module.GetCharacterAndHRP()
    local Character = Player.Character or Player.CharacterAdded:Wait()
    local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
    return Character, HumanoidRootPart
end

do
    local originalIndex = {}
    local spoofedProperties = {}

    function Module.Spoof(obj, property, value)
        if not spoofedProperties[obj] then
            spoofedProperties[obj] = {}
        end
        spoofedProperties[obj][property] = value
        if not originalIndex[obj] then
            local mt = getmetatable(obj)
            if mt and type(mt.__index) == "function" then
                originalIndex[obj] = mt.__index
                mt.__index = function(o, p)
                    if spoofedProperties[o] and spoofedProperties[o][p] then
                        return spoofedProperties[o][p]
                    end
                    return originalIndex[o](o, p)
                end
            end
        end
    end

    function Module.UnSpoof(obj, property)
        if spoofedProperties[obj] then
            spoofedProperties[obj][property] = nil
        end
    end
end

function Module.EnableNoClip(enable)
    local connection
    if enable then
        if setfflag then
            setfflag("HumanoidParallelRemoveNoPhysics", "False")
            setfflag("HumanoidParallelRemoveNoPhysicsNoSimulate2", "False")
        end

        connection = RunService.Stepped:Connect(function()
            for _, v in pairs(Player.Character:GetChildren()) do
                if v:IsA("BasePart") then
                    v.CanCollide = false
                elseif v:IsA("Humanoid") then
                    v:ChangeState(11)
                end
            end
        end)
    else
        if connection then
            connection:Disconnect()
        end
        if setfflag then
            setfflag("HumanoidParallelRemoveNoPhysics", "True")
            setfflag("HumanoidParallelRemoveNoPhysicsNoSimulate2", "True")
        end
    end
    return connection
end

function Module.UltimateTween(object_to_tween, destination, options)
    local Character, HumanoidRootPart = Module.GetCharacterAndHRP()
    local update_rate = options.updateRate or 1/30
    local enableNoClip = options.noClip or true
    local walk_speed = Character.Humanoid.WalkSpeed
    local reachedDestination = false  -- Flag to control the loop

    local function randomInRange(min, max)
        return min + math.random() * (max - min)
    end

    local function getBasePart(object)
        return object.PrimaryPart or object:FindFirstChildWhichIsA("BasePart")
    end

    local function hasReachedDestination(basePart, destination)
        return (basePart.Position - destination.Position).Magnitude < 0.1
    end

    local function updateTween()
        -- Delay in Reaction
        if math.random() < 0.1 then
            wait(randomInRange(0.2, 0.6))
        end

        -- Speed Bursts
        local time = (math.random() < 0.2) and randomInRange(0.5, 1) or randomInRange(1, 5)
        local easing_style, easing_direction = Enum.EasingStyle.Linear, Enum.EasingDirection.In
        local tween_speed = options.speed or "Default"
        local basePart = object_to_tween:IsA("Model") and getBasePart(object_to_tween) or object_to_tween

        -- Micro-Movements
        local microMovement = Vector3.new(randomInRange(-0.5, 0.5), 0, randomInRange(-0.5, 0.5))
        local alteredDestination = destination.Position + microMovement

        -- Unspoof the previous CFrame
        Module.UnSpoof(basePart, 'CFrame')

        -- AntiCheat measures
        if tween_speed == "AntiCheat" then
            local distance_to_destination = (destination.Position - basePart.Position).Magnitude
            time = distance_to_destination / walk_speed
            time = randomInRange(1, 10)
            local lookAtCFrame = CFrame.lookAt(basePart.Position, alteredDestination)
            
            -- Keep the original orientation but update the position
            local originalOrientation = basePart.Orientation
            local newCFrame = CFrame.new(lookAtCFrame.Position, alteredDestination)
            newCFrame = newCFrame * CFrame.Angles(math.rad(originalOrientation.X), math.rad(originalOrientation.Y), math.rad(originalOrientation.Z))
            
            Module.Spoof(basePart, 'CFrame', newCFrame)
        end

        -- Tweening
        local tween_info = TweenInfo.new(time, easing_style, easing_direction)
        local tween_goal = {}
        tween_goal.CFrame = CFrame.new(alteredDestination)
        local tween = TweenService:Create(basePart, tween_info, tween_goal)
        tween:Play()

        -- Check if reached destination
        if hasReachedDestination(basePart, destination) then
            reachedDestination = true  -- Update the flag
        end
    end

    local noClipConnection = Module.EnableNoClip(enableNoClip)  -- Start NoClip

    while not reachedDestination do  -- Use the flag to control the loop
        wait(update_rate)
        updateTween()
    end

    if noClipConnection then  -- Disconnect NoClip
        noClipConnection:Disconnect()
    end
    Module.EnableNoClip(false)  -- Disabling NoClip after tweening
end

return Module
